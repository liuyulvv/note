{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"liuyulvv","text":""},{"location":"Vulkan%20with%20Qt%20as%20GUI/","title":"Vulkan with Qt as GUI","text":"<p>Vulkan is a graphics API and doesn't offer a window to show the rendering result. So sometimes we need other libraries to make this possible, such as glfw.</p> <p>When we use glfw, our codes may look like this:</p> <pre><code>glfwInit();\nglfwWindowHint(glfw_CLIENT_API, glfw_NO_API);\nauto window = glfwCreateWindow(width, height, title, nullptr, nullptr);\nVkSurfaceKHR surface = nullptr;\nglfwCreateWindowSurface(instance, window, nullptr, &amp;surface);\n</code></pre> <p>To enable glfw in Vulkan, we need to enable some extensions when create Vulkan instance, which can get through <code>glfwGetRequiredInstanceExtensions</code>. With the help of glfw, we don't need to process different windows in different operate systems, and we can show our system's rendering result in this surface. It also gives us the ability to handle keyboard, mouse and window resize events, this make our application more exciting.</p> <p>GUI is common in desktop software, such as a button, a radio and check box. Dear ImGUI is a library widely used in Vulkan or OpenGL based application. It makes it very easy to render a button or other GUI components in rendering system.</p> <p><code>ImGUI</code> means immediate mode GUI, if you have used <code>ImGUI</code>, you will find that we need to draw GUI every frame. There are two types of GUI generally, one is <code>immediate mode</code> and another is retained mode. The GUI of Qt is retained mode. I will not compare these two GUI types, chose which type need to consider your own needs.</p> <p>I want to use rich GUI components and layout system of Qt, and I have learned Qt before, so I think Qt is better for me.</p> <p>Qt had supported Vulkan, and it offered <code>QVulkanInstance</code>  and <code>QVulkanWindow</code>. QVulkanInstance and QVulkanWindow free you from making Vulkan instance, selecting physical device, making logical device and many other tedious operations.</p> <p>But this is not accord with my need, because I have spent much time in these tedious operations when I learn Vulkan  , I don't want to waste my code, so I have to spend much time to make my code integrated in Qt.</p> <p><code>glfwCreateWindowSurface</code> help us make <code>VkSurfaceKHR</code> in different systems, we can make <code>VkSurfaceKHR</code> from Qt, I will show how to make it in Windows.</p> <pre><code>#if !defined(VK_USE_PLATFORM_WIN32_KHR)\n#define VK_USE_PLATFORM_WIN32_KHR\n#endif  // VK_USE_PLATFORM_WIN32_KHR\n#include \"vulkan/vulkan.hpp\"\nclass OurWindow : public QWindow {\npublic:\nOurWindow();\nvk::Win32SurfaceCreateInfoKHR getSurfaceInfo();\n}\uff1b\n</code></pre> <p>Firstly, we make <code>OurWindow</code> inherit from <code>QWindow</code> like <code>QVulkanWindow</code>, add a member function <code>getSurfaceInfo</code>, return <code>VkWin32SurfaceCreateInfoKHR</code>. To enable compile your code you have to define <code>VK_USE_PLATFORM_WIN32_KHR</code>.</p> <pre><code>OurWindow::OurWindow() {\nsetSurfaceType(QSurface::VulkanSurface);\n}\n#if defined(_WIN32)\nvk::Win32SurfaceCreateInfoKHR OurWindow::getSurfaceInfo() {\nauto wid = winId();\nvk::Win32SurfaceCreateInfoKHR surfaceInfo{};\nsurfaceInfo.setHwnd(reinterpret_cast&lt;HWND&gt;(wid));\nsurfaceInfo.setHinstance(GetModuleHandle(nullptr));\nreturn surfaceInfo;\n}\n#endif\n// create surface\nm_instance.createWin32SurfaceKHR(surfaceInfo);\n</code></pre> <p>To be continued.</p> <p>Reference: </p> <ul> <li>Qt Vulkan in MacOS</li> </ul>"},{"location":"inline/","title":"inline","text":"<p><code>inline</code> is usually used in <code>class member function</code> like this:</p> <pre><code>// InlineDemo.h\nclass InlineDemo {\npublic:\ninline void Test() {\n// do something\n}\n};\n</code></pre> <p>The <code>inline</code> before <code>void Test</code> can be omitted when the definition is in the <code>class</code>.</p> <p>If you try to definite an <code>inline</code> function outside of a class, you may write the definition in the <code>.h</code> or <code>.cpp</code> file.</p> <p>You can put the definition in a <code>header</code> file outside of the <code>class</code>, but cannot in a <code>source</code> file.</p> <pre><code>// InlineDemo.h\nclass InlineDemo {\npublic:\ninline void Test();\n};\ninline void InlineDemo::Test() {\n// do something\n}\n</code></pre> <p>If in a <code>source</code> file like this:</p> <p>You will get a link error if you invoke inline in another source file.</p> <pre><code>// InlineDemo.h\nclass InlineDemo {\npublic:\ninline void Test();\n};\n// InlineDemo.cpp\ninline void InlineDemo::Test() {\n// do something\n}\n</code></pre> <p>If the definition of an <code>inline</code> function was in a <code>source</code> file, other <code>source</code> cannot invoke this function, you will got a <code>unresolved external</code> error from the linker.</p> <p>According to the Where to put inline keyword, the best practice is putting the <code>inline</code> in <code>definition</code>, don't put in the declaration within class body:</p> <pre><code>// InlineDemo.h\nclass InlineDemo {\npublic:\nvoid Test();  // Don't put inline here\n};\ninline void InlineDemo::Test() {  // Put inline here\n// do something\n}\n</code></pre> <p>Reference:</p> <ul> <li>Must the definition of a C++ inline functions be in the same file?</li> <li>Where to put inline keyword</li> </ul>"},{"location":"string_view/","title":"string_view","text":"<p>| Original link</p> <p>When create a function need to take a (constant) string as an argument, there are three common alternatives:</p> <pre><code>void takeCharStr(const char* s);          // C\nvoid takeString(const std::string&amp; s);    // C++\nvoid takeStringView(std::string_view s);  // C++ 17\n</code></pre> <p><code>takeCharStr</code> and <code>takeString</code> work well if the caller has the string in the format, but when a conversion is needed(either from <code>const char*</code> to <code>std::string</code> or <code>std::string</code> to <code>const char*</code>), the caller have to do some other works.</p> <p>Callers need to convert a <code>std::string</code> to <code>const char*</code> through <code>c_str()</code> function(efficient but inconvenient):</p> <pre><code>void alreadyHasString(const std::string&amp; s) {\ntakeCharStr(s.c_str());  // explicit conversion\n}\n</code></pre> <p>Callers don't need to do anything convert <code>const char*</code> to <code>std::string</code>, but will invoke the creation of a temporary <code>std::string</code>(convenient but inefficient) and copy the temporary string:</p> <pre><code>void alreadyHasCharStr(const char* s) {\ntakeString(s);  // creation and copy\n}\n</code></pre> <p><code>string_view</code> is added to C++ stand since <code>C++ 17</code>. It is a <code>view</code> of an existing character buffer. <code>string_view</code> consists of only a <code>pointer</code> and a <code>length</code>, identifying a section of character data that is not <code>owned</code> by the <code>string_view</code> and cannot be modified by the <code>view</code>. Consequently, making a copy of a <code>string_view</code> is a <code>shallow</code> operation no string data copied.</p> <p><code>string_view</code> has implicit conversion constructors from both <code>const char*</code> and <code>const std::string&amp;</code>, and since <code>string_view</code> doesn\u2019t copy, there is no O(n) memory penalty for making a hidden copy. In the case where a <code>const std::string&amp;</code> is passed, the constructor runs in O(1) time. In the case where a <code>const char*</code> is passed, the constructor invokes a <code>strlen()</code> automatically (or you can use the two-parameter <code>string_view</code> constructor).</p> <pre><code>void alreadyHasString(const std::string&amp; s) {\ntakeStringView(s);  // no explicit conversion; convenient!\n}\nvoid alreadyHasCharStr(const char* s) {\ntakeStringView(s);  // no copy; efficient!\n}\n</code></pre> <p>Because the <code>string_view</code> does not own its data, any strings pointed to by the <code>string_view</code> (just like a <code>const char*</code>) must have a known <code>lifespan</code>, and must outlast the <code>string_view</code> itself. This means that using <code>string_view</code> for storage is often questionable: you need some proof that the underlying data will outlive the <code>string_view</code>.</p> <p>If your API only needs to reference the string data during a single call, and doesn\u2019t need to modify the data, accepting a <code>string_view</code> is sufficient.</p> <p>Changing parameters to pass by <code>string_view</code> can be inefficient if those are then passed to a function requiring a <code>std::string</code> or a <code>NUL-terminated</code> <code>const char*</code>.</p> <p>Unlike other string types, you should pass <code>string_view</code> by value just like you would pass an <code>int</code> or a <code>double</code> because <code>string_view</code> is a small value.</p> <p>Marking a <code>string_view</code> as <code>const</code> only affects whether the <code>string_view</code> object itself can be modified, and not whether it can be used to modify the underlying chars \u2013 it never can. This is exactly analogous to how a <code>const char*</code> can never be used to modify the chars, even if the pointer itself can be modified.</p> <p><code>string_view</code> is not necessarily <code>NUL-terminated</code>.</p>"},{"location":"tips/","title":"Tips","text":"<ul> <li>Qt save <code>*.ui</code> files in a different path(<code>ui</code>) with <code>src</code>, to make this you should update <code>CMakeLists.txt</code> with:</li> </ul> <pre><code>set(CMAKE_AUTOUIC_SEARCH_PATHS ${PROJECT_SOURCE_DIR}/ui)\n</code></pre> <ul> <li><code>clang-tidy</code> check file:</li> </ul> <pre><code>clang-tidy -format-style=file -header-filter=.* -p build src/*.cpp -- -I ./include\n</code></pre> <ul> <li><code>clang-format</code> format file:</li> </ul> <pre><code>clang-format -style=file -i src/*.cpp\n</code></pre>"}]}